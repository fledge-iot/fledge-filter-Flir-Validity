/*
 * Fledge Flir Validity filter plugin.
 *
 *
 * Copyright (c) 2018 Dianomic Systems
 *
 * Released under the Apache 2.0 Licence
 *
 * Author: Massimiliano Pinto
 */

#include <plugin_api.h>
#include <config_category.h>
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <string>
#include <iostream>
#include <filter_plugin.h>
#include <filter.h>
#include <reading_set.h>
#include <regex>
#include <version.h>

#define FILTER_NAME "FlirValidity"

#define LABELS QUOTE({				\
		"areas" : [ "1", "2", "3", "4", \
			"5", "6", "7", "8", "9",\
			"10", "11", "12", "13", \
			"14", "15", "16", "17", \
			"18", "19", "20" ]	\
			})
#if 0
#endif

const char *defaultConfig = QUOTE({
		"plugin" : {
			"description" : "Flir Validity filter plugin",
			"type" : "string",
			"default" : FILTER_NAME,
			"readonly": "true"
		       	},
		"labels" : {
			"description" : "Labels to use for the various areas",
			"type" : "JSON",
			"displayName": "Area Labels",
			"default" : LABELS,
			"order" : "1"
		       	},
		"enable": {
			"description": "A switch that can be used to enable or disable execution of the validity filter.",
			"type": "boolean",
			"displayName": "Enabled",
			"default": "true",
			"order" : "2"
			}
		});

using namespace std;

/**
 * The Filter plugin interface
 */
extern "C" {

/**
 * The plugin information structure
 */
static PLUGIN_INFORMATION info = {
        FILTER_NAME,              // Name
        VERSION,                  // Version
        0,                        // Flags
        PLUGIN_TYPE_FILTER,       // Type
        "1.0.0",                  // Interface version
	defaultConfig	          // Default plugin configuration
};

typedef struct
{
	FledgeFilter			*handle;
	std::string			configCatName;
	std::vector<std::string>	nameMap;
} FILTER_INFO;

/**
 * Return the information about this plugin
 */
PLUGIN_INFORMATION *plugin_info()
{
	return &info;
}

/**
 * Initialise the plugin, called to get the plugin handle and setup the
 * output handle that will be passed to the output stream. The output stream
 * is merely a function pointer that is called with the output handle and
 * the new set of readings generated by the plugin.
 *     (*output)(outHandle, readings);
 * Note that the plugin may not call the output stream if the result of
 * the filtering is that no readings are to be sent onwards in the chain.
 * This allows the plugin to discard data or to buffer it for aggregation
 * with data that follows in subsequent calls
 *
 * @param config	The configuration category for the filter
 * @param outHandle	A handle that will be passed to the output stream
 * @param output	The output stream (function pointer) to which data is passed
 * @return		An opaque handle that is used in all subsequent calls to the plugin
 */
PLUGIN_HANDLE plugin_init(ConfigCategory* config,
			  OUTPUT_HANDLE *outHandle,
			  OUTPUT_STREAM output)
{
	FILTER_INFO *info = new FILTER_INFO;
	info->handle = new FledgeFilter(FILTER_NAME,
					*config,
					outHandle,
					output);
	info->configCatName = config->getName();

	if (config->itemExists("labels"))
	{
		string labels = config->getValue("labels");
		rapidjson::Document doc;
		doc.Parse(labels.c_str());
		if (doc.HasMember("areas") && doc["areas"].IsArray())
		{
			const rapidjson::Value& values = doc["areas"];
			for (rapidjson::Value::ConstValueIterator itr = values.Begin();
						itr != values.End(); ++itr)
			{
				if (itr->IsString())
					info->nameMap.push_back(itr->GetString());
				else
					Logger::getLogger()->error("Configuration error: labels should be strings");
			}
		}
	}

	return (PLUGIN_HANDLE)info;
}

/**
 * Ingest a set of readings into the plugin for processing
 *
 * @param handle	The plugin handle returned from plugin_init
 * @param readingSet	The readings to process
 */
void plugin_ingest(PLUGIN_HANDLE *handle,
		   READINGSET *readingSet)
{
	FILTER_INFO *info = (FILTER_INFO *)handle;
	FledgeFilter *filter = info->handle;
	
	if (!filter->isEnabled())
	{
		// Current filter is not active: just pass the readings set onwards
		filter->m_func(filter->m_data, readingSet);
		return;
	}


	// Just get all the readings in the readingset
	const vector<Reading *>& readings = ((ReadingSet *)readingSet)->getAllReadings();
	// Iterate over the readings
	for (vector<Reading *>::const_iterator elem = readings.begin();
						      elem != readings.end();
						      ++elem)
	{
		AssetTracker::getAssetTracker()->addAssetTrackingTuple(info->configCatName, (*elem)->getAssetName(), string("Filter"));
		// Get a reading DataPoint
		vector<Datapoint *>& dataPoints = (*elem)->getReadingData();
		// Iterate over the datapoints until we find no more xxxValid datapoints
		bool found;
		do {
			found = false;
			string dpName = "";
			for (vector<Datapoint *>::iterator it = dataPoints.begin(); found == false && it != dataPoints.end(); ++it)
			{
				// Get the reference to a DataPointValue
				DatapointValue& value = (*it)->getData();
				string name = (*it)->getName();

				size_t fpos = name.find("Valid");
				if (fpos != string::npos)
				{
					found = true;
					// We have a datapoint that defines the validity of another data point
					if (value.toDouble() < 0.1)
					{
						dpName = name.substr(0, fpos);
					}
					// Remove the *Valid datapoint
					delete *it;
					dataPoints.erase(it);
				}
			}
			// If we found an xxxValid datapoint with a zero value, remove the xxx datapoint as well
			if (dpName.size())
			{
				// We need to find and remove dpName
				for (vector<Datapoint *>::iterator it = dataPoints.begin(); it != dataPoints.end(); ++it)
				{
					if (dpName.compare((*it)->getName()) == 0)
					{
						delete *it;
						dataPoints.erase(it);
						break;
					}
				}
			}
		} while (found);

		// Remove unused spot and delta values
		do {
			found = false;
			for (vector<Datapoint *>::iterator it = dataPoints.begin(); it != dataPoints.end() && found == false; ++it)
			{
				DatapointValue& value = (*it)->getData();
				string name = (*it)->getName();
				size_t fpos = name.find("delta");
				if (fpos != string::npos && value.toDouble() < 0.1 && value.toDouble() > -0.1)
				{
					delete *it;
					dataPoints.erase(it);
					found = true;
				}
				else
				{
					size_t fpos = name.find("spot");
					if (fpos != string::npos && value.toDouble() < 0.1 && value.toDouble() > -0.1)
					{
						delete *it;
						dataPoints.erase(it);
						found = true;
					}
				}
			}
		} while (found);

		// Remove unused bad average values
		do {
			found = false;
			for (vector<Datapoint *>::iterator it = dataPoints.begin(); it != dataPoints.end() && found == false; ++it)
			{
				DatapointValue& value = (*it)->getData();
				string name = (*it)->getName();
				size_t fpos = name.find("average");
				if (fpos != string::npos && value.toDouble() < 0.1 && value.toDouble() > -0.1)
				{
					delete *it;
					dataPoints.erase(it);
					found = true;
				}
			}
		} while (found);

		// Now handle any renaming of the datapoints
		vector<string> &names = info->nameMap;
		for (vector<Datapoint *>::iterator it = dataPoints.begin(); it != dataPoints.end(); ++it)
		{
			string name = (*it)->getName();
			if (name.substr(0, 3).compare("min") == 0)
			{
				int num = atoi(name.substr(3).c_str());
				if (num > 0 && num <= names.size())
				{
					(*it)->setName("min" + names[num-1]);
				}
			}
			else if (name.substr(0, 3).compare("max") == 0)
			{
				int num = atoi(name.substr(3).c_str());
				if (num > 0 && num <= names.size())
				{
					(*it)->setName("max" + names[num-1]);
				}
			}
			else if (name.substr(0, 7).compare("average") == 0)
			{
				int num = atoi(name.substr(7).c_str());
				if (num > 0 && num <= names.size())
				{
					(*it)->setName("average" + names[num-1]);
				}
			}
		}
	}

	// Pass the altered reading set onwards
	filter->m_func(filter->m_data, readingSet);
}

/**
 * Plugin reconfiguration method
 *
 * @param handle	The plugin handle
 * @param newConfig	The updated configuration
 */
void plugin_reconfigure(PLUGIN_HANDLE *handle, const std::string& newConfig)
{
	FILTER_INFO *info = (FILTER_INFO *)handle;
	FledgeFilter* data = info->handle;
	data->setConfig(newConfig);
	ConfigCategory  config("new", newConfig);
	if (config.itemExists("labels"))
	{
		info->nameMap.clear();
		string labels = config.getValue("labels");
		rapidjson::Document doc;
		doc.Parse(labels.c_str());
		if (doc.HasMember("areas") && doc["areas"].IsArray())
		{
			const rapidjson::Value& values = doc["areas"];
			for (rapidjson::Value::ConstValueIterator itr = values.Begin();
						itr != values.End(); ++itr)
			{
				if (itr->IsString())
					info->nameMap.push_back(itr->GetString());
				else
					Logger::getLogger()->error("Configuration error, labels shuld be strings");
			}
		}
	}
}

/**
 * Call the shutdown method in the plugin
 */
void plugin_shutdown(PLUGIN_HANDLE *handle)
{
	FILTER_INFO *info = (FILTER_INFO *) handle;
	delete info->handle;
	delete info;
}

// End of extern "C"
};
